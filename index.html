<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="referrer" content="no-referrer" />
  <link rel="icon" href="data:image/x-icon;," />
  <title>IPTV</title>

  <style>
    /* Minimal styles to reflect referenced classes/IDs used by the script */
    .toast-container { position: absolute; top: 20px; right: 20px; z-index: 9999; }
    .toast { background-color: #333; color: #fff; padding: 10px 20px; border-radius: 5px; margin-bottom: 10px; font-size: 16px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
    #video-container { display: flex; }
    #overlay { display: none; position: absolute; z-index: 50; }
    #epg-container { display: none; }
    #video-list { list-style: none; padding: 0; margin: 0; }
    #video-list li.active { background: #eee; }
  </style>
</head>
<body>
  <div id="app">
    <div id="controls">
      <input id="url-input" type="text" placeholder="Enter playlist URL" />
      <input id="file-input" type="file" accept=".m3u,.m3u8,.txt" />
      <button id="fetch-button">Load</button>
      <input id="search-input" type="search" placeholder="Search channels..." style="display:none;" />
    </div>

    <div id="video-container">
      <video id="video-element" controls></video>
      <div id="overlay" aria-hidden="true"></div>
    </div>

    <aside id="epg-container"></aside>

    <ul id="video-list"></ul>

    <div class="toast-container"></div>
  </div>

  <script>
    // ---------- Core state and DOM refs ----------
    let channels = [];
    let selectedFileContent = null;
    let lastActiveChannel = null;

    const videoContainer = document.getElementById('video-container');
    const overlay = document.getElementById('overlay');
    const videoElement = document.getElementById('video-element');
    const videoList = document.getElementById('video-list');
    const searchInput = document.getElementById('search-input');
    const fetchButton = document.getElementById('fetch-button');
    const fileInput = document.getElementById('file-input');
    const urlInput = document.getElementById('url-input');
    const epgContainer = document.getElementById('epg-container');

    // `player` and `xmlepg` are used in the original script; ensure they exist in the global scope.
    // If your app uses a playback library, that library should set `player` accordingly.
    window.player = window.player || {
      configure: function () {},
      load: function () {}
    };
    window.xmlepg = window.xmlepg || {
      displayPrograms: function () {},
      timelineNeedleRender: function () {}
    };

    // ---------- Helper functions ----------
    function showToast(message) {
      // Add style for toast container if not already present
      if (!document.querySelector('style[data-toast-style]')) {
        const style = document.createElement('style');
        style.setAttribute('data-toast-style', 'true');
        style.innerHTML = `
          .toast-container{position:absolute;top:20px;right:20px;z-index:9999}
          .toast{background-color:#333;color:#fff;padding:10px 20px;border-radius:5px;margin-bottom:10px;font-size:16px;box-shadow:0 4px 6px rgba(0,0,0,0.1)}
        `;
        document.head.appendChild(style);
      }

      const toast = document.createElement('div');
      toast.classList.add('toast');
      toast.textContent = message;

      const container = document.querySelector('.toast-container') || document.createElement('div');
      if (!document.querySelector('.toast-container')) {
        container.classList.add('toast-container');
        document.body.appendChild(container);
      }
      document.querySelector('.toast-container').appendChild(toast);

      setTimeout(() => { toast.remove(); }, 4000);
    }

    function copyToClipboard(text, name) {
      try {
        text = decodeURIComponent(text);
      } catch (e) {
        // if decode fails, keep original
      }
      const normalized = text.replace(/x123x/g, "'");
      navigator.clipboard.writeText(normalized)
        .then(() => { showToast(name + ' command successfully copied to clipboard'); })
        .catch(() => { showToast('Failed to copy ' + name + ' command'); });
    }

    function extractAppendedURL() {
      const params = new URLSearchParams(window.location.search);
      return params.get('file');
    }

    // ---------- Playlist parsing / setting ----------
    async function setPlaylistFromFile(content) {
      await parseAndSetPlaylist(content);
    }

    async function setPlaylistFromUrl(url) {
      // A simple fetch to get the playlist content
      try {
        const res = await fetch(url);
        if (!res.ok) throw new Error('Failed to fetch playlist');
        const text = await res.text();
        await parseAndSetPlaylist(text);
      } catch (err) {
        showToast('Error loading playlist: ' + err.message);
      }
    }

    async function parseAndSetPlaylist(content) {
      // The original uses M3U8Interpreter; we'll call it if present.
      // Fallback: do a simple parse of EXTINF and URL pairs.
      try {
        if (typeof M3U8Interpreter !== 'undefined') {
          const m3u8Interpreter = new M3U8Interpreter(content);
          m3u8Interpreter.parse();
          channels = m3u8Interpreter.getChannels();
          // The original also uses getUrlTvg() and xml EPG logic; we preserve place for that.
          const urls = m3u8Interpreter.getUrlTvg ? m3u8Interpreter.getUrlTvg() : null;
          // (Potentially use urls to populate TV guide)
        } else {
          // Simple parser fallback for basic m3u playlists
          const lines = content.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
          const parsed = [];
          for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            if (line.startsWith('#EXTINF')) {
              const info = line.replace('#EXTINF:', '');
              const nameMatch = info.split(',')[1] || info;
              const urlLine = lines[++i] || '';
              parsed.push({
                channelName: (nameMatch || 'Unknown').trim(),
                url: urlLine,
                tvgLogo: '', // unknown
                tvgId: ''    // unknown
              });
            }
          }
          channels = parsed;
        }

        updatePlaylist(channels);
        const searchEl = document.getElementById('search-input');
        if (searchEl) searchEl.style.display = 'block';
      } catch (err) {
        showToast('Error parsing playlist: ' + err.message);
      }
    }

    // ---------- Player loader ----------
    window.loadVideo = function (manifestUrl, licenseKey) {
      // licenseKey may be a JSON string encoded in URL; decode it if necessary
      if (licenseKey != null && !Array.isArray(licenseKey)) {
        try {
          licenseKey = JSON.parse(decodeURIComponent(licenseKey));
        } catch (e) {
          // leave licenseKey as-is if parse fails
        }
      }

      if (licenseKey) {
        licenseKey.forEach(pair => {
          try {
            player.configure({
              drm: {
                clearKeys: { [pair.keyId]: pair.key }
              }
            });
          } catch (e) {
            // ignore configure errors
            console.warn('Failed to configure DRM clearKeys', e);
          }
        });
      }

      try {
        player.load(manifestUrl);
      } catch (e) {
        // if player.load doesn't exist, attempt to assign to video src
        videoElement.src = manifestUrl;
      }

      try {
        videoElement.play();
      } catch (e) {
        // autoplay may be blocked
      }
    };

    // ---------- Playlist UI ----------
    function updatePlaylist(channelList) {
      videoList.innerHTML = '';

      channelList.forEach(channel => {
        const listItem = document.createElement('li');

        // Compose inner HTML similar to the compiled output
        listItem.innerHTML = `
          <div class="channel-item">
            <img src="${channel.tvgLogo || ''}" alt="${channel.channelName} logo" />
            <span class="channel-name">${channel.channelName || 'Unknown'}</span>
          </div>
        `;

        // Wire events on the image for showing EPG overlay
        const imgElement = listItem.querySelector('img');
        if (imgElement) {
          imgElement.addEventListener('mouseenter', () => {
            try {
              xmlepg.displayPrograms('overlay', channel.tvgId);
            } catch (e) {}
            overlay.style.display = 'flex';
            videoContainer.style.display = 'none';
          });

          // When overlay is left, hide it and return to video container
          overlay.addEventListener('mouseleave', () => {
            overlay.style.display = 'none';
            videoContainer.style.display = 'flex';
          });
        }

        // Clicking a channel loads it
        listItem.addEventListener('click', () => {
          // mark active
          const prev = videoList.querySelector('li.active');
          if (prev) prev.classList.remove('active');
          listItem.classList.add('active');

          // store last active HTML (keeps parity with original minified behavior)
          lastActiveChannel = listItem.innerHTML;

          // Load the channel's URL (manifest)
          if (channel.url) {
            window.loadVideo(channel.url, channel.licenseKey || null);
          }
        });

        videoList.appendChild(listItem);
      });
    }

    function filterPlaylist(searchTerm) {
      const filteredChannels = channels.filter(channel =>
        (channel.channelName || '').toLowerCase().includes((searchTerm || '').toLowerCase())
      );
      updatePlaylist(filteredChannels);
    }

    // ---------- Event wiring ----------
    fetchButton.addEventListener('click', async () => {
      const url = urlInput.value.trim();
      if (selectedFileContent) {
        await setPlaylistFromFile(selectedFileContent);
      } else if (url) {
        await setPlaylistFromUrl(url);
      } else {
        showToast('Please provide a URL or choose a file');
      }
    });

    fileInput.addEventListener('change', async (ev) => {
      const file = ev.target.files && ev.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => {
        selectedFileContent = reader.result;
        setPlaylistFromFile(selectedFileContent);
      };
      reader.readAsText(file);
    });

    searchInput.addEventListener('input', (event) => {
      const searchTerm = event.target.value;
      filterPlaylist(searchTerm);
    });

    // Example function from minified file
    function openEPG() {
      epgContainer.style.display = 'block';
      try {
        xmlepg.timelineNeedleRender();
      } catch (e) {}
    }

    // On page load: check for appended "file" param and load if provided
    (function init() {
      const appended = extractAppendedURL();
      if (appended) {
        // appended may be a URL; attempt to load
        setPlaylistFromUrl(appended);
      }
    })();
  </script>
</body>
</html>
